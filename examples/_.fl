/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}

/*
    Floral Example - All syntax usage
    Used for lexer test cases
*/

fn greet(name: String): String {
    return fmt("Hello, {name}!")
}

// OOP
trait Updatable {
    fn update(dt: float)
}

struct Entity impl Updatable {
    id: int
    pos: Vec2

    fn init(id: int, pos: Vec2) {
        self.id = id
        self.pos = pos
    }
}

struct Player impl Entity {
    health: int

    fn init(id: int, pos: Vec2, health: int) {
        super.init(id, pos)
        self.health = health
    }

    fn update(dt: float) {
        print("Player {self.id} is updating.")
        self.pos.x += dt * 5.0
    }

    fn take_damage(amount: int) {
        self.health -= amount
    }
}

// Operator override
struct Vec2 {
    x: float
    y: float

    fn Operator::add(other: Self): Self {
        return Self(self.x + other.x, self.y + other.y)
    }

    fn Operator::mult(scalar: float): Self {
        return Self(self.x * scalar, self.y * scalar)
    }
}

// Conditional logic and loops
fn main() {
    let mut player = Player {
        id: 1,
        pos: Vec2 { x: 0.0, y: 0.0 },
        health: 100,
    };

    player.init(1, Vec2 { x: 10.0, y: 20.0 }, 100);
    
    let mut dt = 0.1;
    
    for _ in 0..100 {
        player.update(dt);
        dt += 0.1;
    }

    player.take_damage(10);
    println!("Player health: {}", player.health);

    // Handling various conditions
    if player.health <= 0 {
        println!("Player is dead!");
    } else {
        println!("Player is alive.");
    }

    // Example of operator overloading in action
    let v1 = Vec2 { x: 1.0, y: 2.0 };
    let v2 = Vec2 { x: 3.0, y: 4.0 };
    
    let result = v1 + v2; // Using overloaded operator `add`
    println!("Result of Vec2 addition: ({}, {})", result.x, result.y);
    
    let scaled = v1 * 2.0; // Using overloaded operator `mult`
    println!("Scaled Vec2: ({}, {})", scaled.x, scaled.y);

    // Loop examples
    let mut counter = 0;
    while counter < 5 {
        println!("Counter is: {}", counter);
        counter += 1;
    }

    // Switch or pattern matching (hypothetical)
    match player.health {
        0 => println!("Player is dead."),
        1..=50 => println!("Player has low health."),
        _ => println!("Player is in good condition."),
    }

    // Example of function return
    let greeting = greet("Alice".to_string());
    println!("{}", greeting);

    // File IO or system interaction (example)
    let filename = "player_data.txt";
    if let Ok(contents) = std::fs::read_to_string(filename) {
        println!("File contents: {}", contents);
    } else {
        println!("Could not read file.");
    }
}
